---
category: "Структурные"
name: "Адаптер"
articleId: "adapter"
keywords:
    [
        "паттерн адаптер",
        "adapter pattern",
        "шаблон проектирования адаптер",
        "адаптер javascript",
        "javascript adapter",
        "паттерны проектирования",
        "структурные паттерны",
        "шаблоны проектирования",
        "дизайн паттерны",
        "пример адаптера",
        "адаптер класс объект",
        "паттерн мост vs адаптер",
        "паттерн адаптер реальный пример",
        "адаптер подключение несовместимых интерфейсов",
    ]
---

# Адаптер (Adapter)

Cтруктурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он выступает в роли обёртки между двумя объектами, преобразуя интерфейс одного объекта в интерфейс, ожидаемый другим.

## Применение

✔ требуется использование стороннего кода с несовместимым интерфейсом;\
✔ нужно интегрировать старую систему с новой, не меняя её исходный код;\
✔ класс не реализует нужный интерфейс, но его функциональность необходимо использовать.

## Аналогия из жизни

Представьте, что вы приехали в другую страну, где розетки отличаются от ваших. Вместо того чтобы покупать новую технику, вы используете **переходник (адаптер)** — он позволяет подключить вашу вилку к местной розетке. Точно так же работает и паттерн Адаптер в коде.

## Схема реализации

```text
   Клиент (Client)
         |
         v
  ┌────────────┐
  │  Target    │<────────────┐
  └────────────┘             │
         ▲                   │
         │                   │
   ┌────────────┐            │
   │  Adapter   │────────────┘
   └────────────┘
         │
         v
  ┌────────────┐
  │ Adaptee    │
  └────────────┘
```

## Примеры

### 1. Реализация на JavaScript

```javascript
// Сторонний класс с несовместимым интерфейсом
class OldAPI {
    specificRequest() {
        return "Данные от старого API";
    }
}

// Адаптер, который преобразует интерфейс
class Adapter {
    constructor(oldApiInstance) {
        this.oldApi = oldApiInstance;
    }

    request() {
        return this.oldApi.specificRequest();
    }
}

// Клиентский код работает с адаптированным интерфейсом
const oldApi = new OldAPI();
const adapter = new Adapter(oldApi);

// Данные от старого API
console.log(adapter.request());
```

## Преимущества и недостатки

✔ Позволяет использовать существующий код без изменений.\
✔ Повышает гибкость системы.\
✔ Обеспечивает совместимость между интерфейсами.

❌ Может усложнить структуру программы.\
❌ Повышает количество классов в проекте.

## Отличие от других паттернов

Декоратор добавляет поведение, не меняя интерфейс.\
Мост разделяет абстракцию и реализацию.\
Адаптер только преобразует интерфейс без добавления новой функциональности.
